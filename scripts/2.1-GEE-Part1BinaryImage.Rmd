---
title: "GEE Part 1 Binary burned/unburned image"
author: "Anna Talucci"
date: "8/26/2021"
output: html_document
---

# Overview
The first of two scripts run in Google Earth Engine (GEE). Script is saved in my personal reposititory, FLARE-Fire-Activity, script, Part1-FLARE-Binary-Eco-Harm.


[Link to GEE code](https://code.earthengine.google.com/?scriptPath=users%2Factalucci%2FFLARE-FireActivity%3APart1-FLARE-Binary-Eco-Harm) 

```{js}
/*Part 1: Binary raster of burned/unburned
By Ecozone
    
    Script by Anna Talucci  
    Started Octobeer 2020 (copied from Part1-NES-binaryImage)
    For updates or questions on this code, please can contact:  
        Anna Talucci actalucci@gmail.com

    Notes: 

Part 1: Produces a Binary burned/unburned image and  exports to assets
*/

// Center Map
Map.setCenter(160.092, 66.704, 5);

// changes years for specific fire year
var pre = '2019' //Year prefire
var year = '2020' //Fire year
var post = '2021'//Year postfire

// Projection Equal Area (https://spatialreference.org/ref/sr-org/albers-equal-area-russia/)
var proj = ee.Projection('PROJCS["Albers Conical Equal Area",GEOGCS["WGS 84",DATUM["WGS_1984",SPHEROID["WGS 84",6378137,298.257223563,AUTHORITY["EPSG","7030"]],TOWGS84[0,0,0,0,0,0,0],AUTHORITY["EPSG","6326"]],PRIMEM["Greenwich",0,AUTHORITY["EPSG","8901"]],UNIT["degree",0.0174532925199433,AUTHORITY["EPSG","9108"]],AUTHORITY["EPSG","4326"]],PROJECTION["Albers_Conic_Equal_Area"],PARAMETER["standard_parallel_1",50],PARAMETER["standard_parallel_2",70],PARAMETER["latitude_of_center",56],PARAMETER["longitude_of_center",100],PARAMETER["false_easting",0],PARAMETER["false_northing",0],UNIT["meters",1]]').atScale(10000)

// Ecozone Poly
var NEPoly1_ee = "NEPoly1_ee"
var E_EPoly2_1_ee = "E_EPoly2_1_ee"
var W_EPoly2_2_ee = "W_EPoly2_2_ee"

//Change eco_code for each iteration
var eco_code = NEPoly1_ee

// Feature collection
var ecozone_poly = ee.FeatureCollection('users/actalucci/FLARE-Ecozones/eco_'+eco_code)
var aoi = ecozone_poly

// VISUALIZATION PARAMETERS 
var viz = {min: -0.1, max: 1, palette: ['00FFFF', '0000FF']};
var dnbrViz = {min: -100, max: 1500, palette: ['7CFC00', 'FFFF00', 'FFA500', 'FF0000']};
var vizParams = {bands: ['B5', 'B4', 'B3'], min: 0, max: 0.5, gamma: [0.95, 1.1, 1] };

// ################################################################
// ### FUNCTIONS ###
// ################################################################

// Define coefficients supplied by Roy et al. (2016) for translating ETM+
// surface reflectance to OLI surface reflectance.
var coefficients = {
  itcps: ee.Image.constant([0.0003, 0.0088, 0.0061, 0.0412, 0.0254, 0.0172]).multiply(10000),
  slopes: ee.Image.constant([0.8474, 0.8483, 0.9047, 0.8462, 0.8937, 0.9071])
};

// Define function to get and rename bands of interest from OLI.
function renameOLI(img) {
  return img.select(
		['B2', 'B3', 'B4', 'B5', 'B6', 'B7', 'pixel_qa'],
		['Blue', 'Green', 'Red', 'NIR', 'SWIR1', 'SWIR2', 'pixel_qa']
	);
}

// Define function to get and rename bands of interest from ETM+.
function renameETM(img) {
  return img.select(
		['B1', 'B2', 'B3', 'B4', 'B5', 'B7', 'pixel_qa'],
		['Blue', 'Green', 'Red', 'NIR', 'SWIR1', 'SWIR2', 'pixel_qa']
  );
}

// Define function to apply harmonization transformation.
function etm2oli(img) {
  return img.select(['Blue', 'Green', 'Red', 'NIR', 'SWIR1', 'SWIR2'])
    .multiply(coefficients.slopes)
    .add(coefficients.itcps)
    .round()
    .toShort()
    .addBands(img.select('pixel_qa')
  );
}

// Define function to mask out clouds and cloud shadows.
function fmask(img) {
  var cloudShadowBitMask = 1 << 3;
  var cloudsBitMask = 1 << 5;
  var waterBitMask = 1 << 2;
  var snowBitMask = 1 << 4;
  var qa = img.select('pixel_qa');
  var mask = qa.bitwiseAnd(cloudShadowBitMask).eq(0)
    .and(qa.bitwiseAnd(cloudsBitMask).eq(0)
    .and(qa.bitwiseAnd(waterBitMask).eq(0)
    .and(qa.bitwiseAnd(snowBitMask).eq(0))));
  return img.updateMask(mask);
}

// Define function to calculate NBR.
function calcNBR(img) {
  return img.normalizedDifference(['NIR', 'SWIR2']).rename('nbr');
}

// Define function to prepare OLI images.
function prepOLI(img) {
  var orig = img;
  img = renameOLI(img);
  img = fmask(img);
  img = calcNBR(img);
  return ee.Image(img.copyProperties(orig, orig.propertyNames()));
}

// Define function to prepare ETM+ images.
function prepETM(img) {
  var orig = img;
  img = renameETM(img);
  img = fmask(img);
  img = etm2oli(img);
  img = calcNBR(img);
  return ee.Image(img.copyProperties(orig, orig.propertyNames()));
}

// ################################################################
// ### APPLICATION ###
// ################################################################

// Display AOI on the map.
// Map.centerObject(aoi, 10);
// Map.addLayer(aoi, {color: 'f8766d'}, 'AOI');
// Map.setOptions('HYBRID');

// Get Landsat surface reflectance collections for OLI, ETM+ and TM sensors.
var oliCol = ee.ImageCollection('LANDSAT/LC08/C01/T1_SR');
var etmCol= ee.ImageCollection('LANDSAT/LE07/C01/T1_SR');
var tmCol= ee.ImageCollection('LANDSAT/LT05/C01/T1_SR');

// Define a collection filter.
var colFilter = ee.Filter.and(
  ee.Filter.bounds(aoi),
  ee.Filter.date(pre+'-05-01', post+'-08-30'),
    ee.Filter.lt('CLOUD_COVER', 50),
  ee.Filter.lt('GEOMETRIC_RMSE_MODEL', 10),
  ee.Filter.or(
    ee.Filter.eq('IMAGE_QUALITY', 9),
    ee.Filter.eq('IMAGE_QUALITY_OLI', 9)
  )
);

// Filter collections and prepare them for merging.
oliCol = oliCol.filter(colFilter).map(prepOLI);
etmCol= etmCol.filter(colFilter).map(prepETM);
tmCol= tmCol.filter(colFilter).map(prepETM);

// Merge the collections.
var ls_full = oliCol
  .merge(etmCol)
  .merge(tmCol);

// Pre and Post fire imagery
var prefire = ee.ImageCollection(ls_full.filterDate(pre+'-05-01', pre+'-08-30').filterBounds(aoi).sort('CLOUD_COVER_LAND')),
    postfire = ee.ImageCollection(ls_full.filterDate(post+'-05-01', post+'-08-30').filterBounds(aoi).sort('CLOUD_COVER_LAND'));


var nbr = ee.ImageCollection(ls_full.filterDate(year + '-05-01', year + '-08-30').filterBounds(aoi).sort('CLOUD_COVER_LAND')).median().select('nbr').multiply(1000)
 
// Generate a annual composite 
var q_prefire = prefire.qualityMosaic('nbr').select('nbr').multiply(1000),
    q_postfire = postfire.qualityMosaic('nbr').select('nbr').multiply(1000);


// Calculate dNBR      
var dnbr = q_prefire.subtract(q_postfire).select('nbr')
Map.addLayer(dnbr, dnbrViz, 'dnbr')
// Map.addLayer(nbr, {}, 'nbr')
// Map.addLayer(hotspots, {}, 'hotspots')

// var rdnbr_bottom = q_prefire.divide(1000).abs().sqrt().select('nbr');
// var rdnbr = dnbr.divide(rdnbr_bottom); 
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

//      Generate binary raster - burned and unburned

var bin_raster = dnbr.gte(100)//returns 1 as burned and 0 as unburned; RdNBR value from Miller and Thode; can switch to dNBR value greater than 100
// Map.addLayer(bin_raster, {}, 'bin_raster')

var resample_median5 = bin_raster.reduceNeighborhood({reducer: ee.Reducer.median(), kernel: ee.Kernel.square(5, 'pixels'),});

///////////////////////////////////////////////////////////////////////////////////

//------------------------- EXPORT TO ASSET --------------------------------------//
// Export the image to an Earth Engine asset.
Export.image.toAsset({
  image: resample_median5,
  description:eco_code+'_dnbrBinaryHarmEA_'+year,
  assetId:eco_code+'_dnbrBinaryHarmEA_'+year,
  scale: 30,
  crs: proj,
  region: aoi,
  maxPixels: 1e13
});

```